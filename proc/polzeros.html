<!-- -*- mode: jinja2 -*- -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Polynomial Roots with Modern Fortran">
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>polzeros &ndash; polyroots-fortran</title>

    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <!-- Font Awesome -->
    <link href="../css/fontawesome.min.css" rel="stylesheet">
    <link href="../css/brands.min.css" rel="stylesheet">
    <link href="../css/regular.min.css" rel="stylesheet">
    <link href="../css/solid.min.css" rel="stylesheet">
    <link href="../css/v4-font-face.min.css" rel="stylesheet">
    <link href="../css/v4-shims.min.css" rel="stylesheet">
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async
            integrity="sha256-DViIOMYdwlM/axqoGDPeUyf0urLoHMN4QACBKyB58Uw=" crossorigin="anonymous"></script>
    <!-- Other scripts and stylesheets -->
    <link href="../css/local.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <script src="../js/svg-pan-zoom.min.js"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">polyroots-fortran </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                  <li class="nav-item">
                    <a class="nav-link" href="../sourcefile/polyroots_module.f90.html">Source File</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
  <div class="row">
    <h1>polzeros
      <small>Subroutine</small>
      
    </h1>
      <div class="container p-2 mb-4 bg-light border rounded-3">
    <div class="row align-items-center justify-content-between" id="info-bar">
      <div class="col">
        <ul class="list-inline" style="margin-bottom:0px;display:inline">

            <li class="list-inline-item" id="statements"><i class="fa fa-list-ol"></i>
              <a data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true"
                 title=" 1.5% of total for procedures.">64 statements</a>
            </li>

            <li class="list-inline-item" id="source-file">
              <i class="fa fa-code"></i>
              <a href="../src/polyroots_module.F90"> Source File</a>
            </li>
        </ul>
      </div>
      <div class="col">
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb justify-content-end mb-0">
                <li class="breadcrumb-item"><a href='../sourcefile/polyroots_module.f90.html'>polyroots_module.F90</a></li>
                <li class="breadcrumb-item"><a href='../module/polyroots_module.html'>polyroots_module</a></li>
            <li class="breadcrumb-item active" aria-current="page">polzeros</li>
          </ol>
        </nav>
      </div>
    </div>
  </div>
  <script>
    // Enable Bootstrap tooltips
    (function () {
      const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
      const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
    })();
  </script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
      <div id="sidebar">
      <h3>Contents</h3>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
    <div class="card card-primary">
      <div class="card-header text-left"><h3 class="card-title">Source Code</h3></div>
      <div class="list-group">
        <a class="list-group-item" href="../proc/polzeros.html#src">polzeros</a>
      </div>
    </div>


  </div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>public  subroutine polzeros(n, poly, nitmax, root, radius, err)  
</h2>
    

    <p>Numerical computation of the roots of a polynomial having
  complex coefficients, based on aberth's method.</p>
<p>this routine approximates the roots of the polynomial
  <code>p(x)=a(n+1)x^n+a(n)x^(n-1)+...+a(1), a(j)=cr(j)+i ci(j), i**2=-1</code>,
  where <code>a(1)</code> and <code>a(n+1)</code> are nonzero.</p>
<p>the coefficients are complex numbers. the routine is fast, robust
  against overflow, and allows to deal with polynomials of any degree.
  overflow situations are very unlikely and may occurr if there exist
  simultaneously coefficients of moduli close to big and close to
  small, i.e., the greatest and the smallest positive real(wp) numbers,
  respectively. in this limit situation the program outputs a warning
  message. the computation can be speeded up by performing some side
  computations in single precision, thus slightly reducing the
  robustness of the program (see the comments in the routine aberth).
  besides a set of approximations to the roots, the program delivers a
  set of a-posteriori error bounds which are guaranteed in the most
  part of cases. in the situation where underflow does not allow to
  compute a guaranteed bound, the program outputs a warning message
  and sets the bound to 0. in the situation where the root cannot be
  represented as a complex(wp) number the error bound is set to -1.</p>
<p>the computation is performed by means of aberth's method
  according to the formula</p>
<div class="codehilite"><pre><span></span><code>           x(i)=x(i)-newt/(1-newt*abcorr), i=1,...,n             (1)
</code></pre></div>

<p>where <code>newt=p(x(i))/p'(x(i))</code> is the newton correction and <code>abcorr=
  =1/(x(i)-x(1))+...+1/(x(i)-x(i-1))+1/(x(i)-x(i+1))+...+1/(x(i)-x(n))</code>
  is the aberth correction to the newton method.</p>
<p>the value of the newton correction is computed by means of the
  synthetic division algorithm (ruffini-horner's rule) if |x|&lt;=1,
  otherwise the following more robust (with respect to overflow)
  formula is applied:</p>
<div class="codehilite"><pre><span></span><code>                    newt=1/(n*y-y**2 r&#39;(y)/r(y))                 (2)
</code></pre></div>

<p>where</p>
<div class="codehilite"><pre><span></span><code>                    y=1/x
                    r(y)=a(1)*y**n+...+a(n)*y+a(n+1)            (2&#39;)
</code></pre></div>

<p>this computation is performed by the routine <a href="../proc/newton.html">newton</a>.</p>
<p>the starting approximations are complex numbers that are
  equispaced on circles of suitable radii. the radius of each
  circle, as well as the number of roots on each circle and the
  number of circles, is determined by applying rouche's theorem
  to the functions <code>a(k+1)*x**k</code> and <code>p(x)-a(k+1)*x**k, k=0,...,n</code>.
  this computation is performed by the routine <a href="../proc/start.html">start</a>.</p>
<h3>stop condition</h3>
<p>if the condition</p>
<div class="codehilite"><pre><span></span><code>                     |p(x(j))|&lt;eps s(|x(j)|)                      (3)
</code></pre></div>

<p>is satisfied, where <code>s(x)=s(1)+x*s(2)+...+x**n * s(n+1)</code>,
 <code>s(i)=|a(i)|*(1+3.8*(i-1))</code>, <code>eps</code> is the machine precision (eps=2**-53
 for the ieee arithmetic), then the approximation <code>x(j)</code> is not updated
 and the subsequent iterations (1)  for <code>i=j</code> are skipped.
 the program stops if the condition (3) is satisfied for <code>j=1,...,n</code>,
 or if the maximum number <code>nitmax</code> of iterations has been reached.
 the condition (3) is motivated by a backward rounding error analysis
 of the ruffini-horner rule, moreover the condition (3) guarantees
 that the computed approximation <code>x(j)</code> is an exact root of a slightly
 perturbed polynomial.</p>
<h3>inclusion disks, a-posteriori error bounds</h3>
<p>for each approximation <code>x</code> of a root, an a-posteriori absolute error
 bound r is computed according to the formula</p>
<div class="codehilite"><pre><span></span><code>                   r=n(|p(x)|+eps s(|x|))/|p&#39;(x)|                 (4)
</code></pre></div>

<p>this provides an inclusion disk of center <code>x</code> and radius <code>r</code> containing a
 root.</p>
<h3>Reference</h3>
<ul>
<li>Dario Andrea Bini, "<a href="https://link.springer.com/article/10.1007/BF02207694">Numerical computation of polynomial zeros by means of Aberth's method</a>"
    Numerical Algorithms volume 13, pages 179-200 (1996)</li>
</ul>
<h3>History</h3>
<ul>
<li>version 1.4, june 1996
    (d. bini, dipartimento di matematica, universita' di pisa)
    (bini@dm.unipi.it)
    work performed under the support of the esprit bra project 6846 posso
    Source: <a href="https://netlib.org/numeralgo/na10">Netlib</a></li>
<li>Jacob Williams, 9/19/2022, modernized this code</li>
</ul>


    <h3>Arguments</h3>
        <table class="table table-striped varlist">
    <thead>
      <tr>
        <th scope="col">Type</th>
<th scope="col">Intent</th><th scope="col">Optional</th>        <th scope="col">Attributes</th>
        <th scope="col"></th>
        <th scope="col">Name</th>
        <th scope="col"></th>
    </thead>
    <tbody>
        <tr>
            <td>
              <span class="anchor" id="variable-n~25"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>n</strong></td>
            <td>
                <p>degree of the polynomial.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-poly~5"></span>
              complex(kind=wp),
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>poly</strong>(n+1)</td>
            <td>
                <p>complex vector of n+1 components, <code>poly(i)</code> is the
coefficient of <code>x**(i-1), i=1,...,n+1</code> of the polynomial <code>p(x)</code></p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-nitmax"></span>
              integer,
            </td>
<td>intent(in)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>nitmax</strong></td>
            <td>
                <p>the max number of allowed iterations.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-root~5"></span>
              complex(kind=wp),
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>root</strong>(n)</td>
            <td>
                <p>complex vector of <code>n</code> components, containing the
approximations to the roots of <code>p(x)</code>.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-radius"></span>
              real(kind=wp),
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>radius</strong>(n)</td>
            <td>
                <p>real vector of <code>n</code> components, containing the error bounds to
the approximations of the roots, i.e. the disk of center
<code>root(i)</code> and radius <code>radius(i)</code> contains a root of <code>p(x)</code>, for
<code>i=1,...,n</code>. <code>radius(i)</code> is set to -1 if the corresponding root
cannot be represented as floating point due to overflow or
underflow.</p>
            </td>
        </tr>
        <tr>
            <td>
              <span class="anchor" id="variable-err"></span>
              logical,
            </td>
<td>intent(out)</td>
              <td></td>            <td>
              
            </td>
            <td>::</td>
            <td><strong>err</strong>(n)</td>
            <td>
                <p>vector of <code>n</code> components detecting an error condition:</p>
<ul>
<li><code>err(j)=.true.</code> if after <code>nitmax</code> iterations the stop condition
   (3) is not satisfied for x(j)=root(j);</li>
<li><code>err(j)=.false.</code>  otherwise, i.e., the root is reliable,
   i.e., it can be viewed as an exact root of a
   slightly perturbed polynomial.</li>
</ul>
<p>the vector <code>err</code> is used also in the routine convex hull for
storing the abscissae of the vertices of the convex hull.</p>
            </td>
        </tr>
    </tbody>
  </table>

    <br>
    <div class="card">
      <div class="card-header">
  <h3 class="card-title">Calls</h3>
      </div>
      <div class="card-body">
  <div class="depgraph"><?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: proc~~polzeros~~CallsGraph Pages: 1 -->
<svg id="procpolzerosCallsGraph" width="425pt" height="158pt"
 viewBox="0.00 0.00 425.00 158.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="proc~~polzeros~~CallsGraph" class="graph" transform="scale(1 1) rotate(0) translate(4 154)">
<title>proc~~polzeros~~CallsGraph</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-154 421,-154 421,4 -4,4"/>
<!-- proc~polzeros -->
<g id="proc~~polzeros~~CallsGraph_node1" class="node">
<title>proc~polzeros</title>
<polygon fill="none" stroke="black" points="57,-108 0,-108 0,-84 57,-84 57,-108"/>
<text text-anchor="middle" x="28.5" y="-93.6" font-family="Helvetica,sans-Serif" font-size="10.50">polzeros</text>
</g>
<!-- proc~aberth -->
<g id="proc~~polzeros~~CallsGraph_node2" class="node">
<title>proc~aberth</title>
<g id="a_proc~~polzeros~~CallsGraph_node2"><a xlink:href="../proc/aberth.html" xlink:title="aberth">
<polygon fill="#d9534f" stroke="#d9534f" points="147,-150 93,-150 93,-126 147,-126 147,-150"/>
<text text-anchor="middle" x="120" y="-135.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">aberth</text>
</a>
</g>
</g>
<!-- proc~polzeros&#45;&gt;proc~aberth -->
<g id="proc~~polzeros~~CallsGraph_edge1" class="edge">
<title>proc~polzeros&#45;&gt;proc~aberth</title>
<path fill="none" stroke="#000000" d="M55.39,-108.15C64.29,-112.33 74.42,-117.08 83.93,-121.54"/>
<polygon fill="#000000" stroke="#000000" points="82.63,-124.8 93.17,-125.88 85.61,-118.46 82.63,-124.8"/>
</g>
<!-- proc~newton -->
<g id="proc~~polzeros~~CallsGraph_node3" class="node">
<title>proc~newton</title>
<g id="a_proc~~polzeros~~CallsGraph_node3"><a xlink:href="../proc/newton.html" xlink:title="newton">
<polygon fill="#d9534f" stroke="#d9534f" points="147,-108 93,-108 93,-84 147,-84 147,-108"/>
<text text-anchor="middle" x="120" y="-93.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">newton</text>
</a>
</g>
</g>
<!-- proc~polzeros&#45;&gt;proc~newton -->
<g id="proc~~polzeros~~CallsGraph_edge2" class="edge">
<title>proc~polzeros&#45;&gt;proc~newton</title>
<path fill="none" stroke="#000000" d="M57.33,-96C65.35,-96 74.23,-96 82.69,-96"/>
<polygon fill="#000000" stroke="#000000" points="82.72,-99.5 92.72,-96 82.72,-92.5 82.72,-99.5"/>
</g>
<!-- proc~start -->
<g id="proc~~polzeros~~CallsGraph_node4" class="node">
<title>proc~start</title>
<g id="a_proc~~polzeros~~CallsGraph_node4"><a xlink:href="../proc/start.html" xlink:title="start">
<polygon fill="#d9534f" stroke="#d9534f" points="147,-66 93,-66 93,-42 147,-42 147,-66"/>
<text text-anchor="middle" x="120" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">start</text>
</a>
</g>
</g>
<!-- proc~polzeros&#45;&gt;proc~start -->
<g id="proc~~polzeros~~CallsGraph_edge3" class="edge">
<title>proc~polzeros&#45;&gt;proc~start</title>
<path fill="none" stroke="#000000" d="M55.39,-83.85C64.29,-79.67 74.42,-74.92 83.93,-70.46"/>
<polygon fill="#000000" stroke="#000000" points="85.61,-73.54 93.17,-66.12 82.63,-67.2 85.61,-73.54"/>
</g>
<!-- proc~cnvex -->
<g id="proc~~polzeros~~CallsGraph_node5" class="node">
<title>proc~cnvex</title>
<g id="a_proc~~polzeros~~CallsGraph_node5"><a xlink:href="../proc/cnvex.html" xlink:title="cnvex">
<polygon fill="#d9534f" stroke="#d9534f" points="237,-66 183,-66 183,-42 237,-42 237,-66"/>
<text text-anchor="middle" x="210" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">cnvex</text>
</a>
</g>
</g>
<!-- proc~start&#45;&gt;proc~cnvex -->
<g id="proc~~polzeros~~CallsGraph_edge4" class="edge">
<title>proc~start&#45;&gt;proc~cnvex</title>
<path fill="none" stroke="#000000" d="M147.4,-54C155.39,-54 164.31,-54 172.82,-54"/>
<polygon fill="#000000" stroke="#000000" points="172.92,-57.5 182.92,-54 172.92,-50.5 172.92,-57.5"/>
</g>
<!-- proc~cmerge -->
<g id="proc~~polzeros~~CallsGraph_node6" class="node">
<title>proc~cmerge</title>
<g id="a_proc~~polzeros~~CallsGraph_node6"><a xlink:href="../proc/cmerge.html" xlink:title="cmerge">
<polygon fill="#d9534f" stroke="#d9534f" points="327,-66 273,-66 273,-42 327,-42 327,-66"/>
<text text-anchor="middle" x="300" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">cmerge</text>
</a>
</g>
</g>
<!-- proc~cnvex&#45;&gt;proc~cmerge -->
<g id="proc~~polzeros~~CallsGraph_edge5" class="edge">
<title>proc~cnvex&#45;&gt;proc~cmerge</title>
<path fill="none" stroke="#000000" d="M237.4,-54C245.39,-54 254.31,-54 262.82,-54"/>
<polygon fill="#000000" stroke="#000000" points="262.92,-57.5 272.92,-54 262.92,-50.5 262.92,-57.5"/>
</g>
<!-- proc~ctest -->
<g id="proc~~polzeros~~CallsGraph_node7" class="node">
<title>proc~ctest</title>
<g id="a_proc~~polzeros~~CallsGraph_node7"><a xlink:href="../proc/ctest.html" xlink:title="ctest">
<polygon fill="#d94e8f" stroke="#d94e8f" points="417,-108 363,-108 363,-84 417,-84 417,-108"/>
<text text-anchor="middle" x="390" y="-93.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">ctest</text>
</a>
</g>
</g>
<!-- proc~cmerge&#45;&gt;proc~ctest -->
<g id="proc~~polzeros~~CallsGraph_edge6" class="edge">
<title>proc~cmerge&#45;&gt;proc~ctest</title>
<path fill="none" stroke="#000000" d="M326.45,-66.15C335.21,-70.33 345.17,-75.08 354.52,-79.54"/>
<polygon fill="#000000" stroke="#000000" points="353.07,-82.73 363.6,-83.88 356.09,-76.41 353.07,-82.73"/>
</g>
<!-- proc~left -->
<g id="proc~~polzeros~~CallsGraph_node8" class="node">
<title>proc~left</title>
<g id="a_proc~~polzeros~~CallsGraph_node8"><a xlink:href="../proc/left.html" xlink:title="left">
<polygon fill="#d9534f" stroke="#d9534f" points="417,-66 363,-66 363,-42 417,-42 417,-66"/>
<text text-anchor="middle" x="390" y="-51.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">left</text>
</a>
</g>
</g>
<!-- proc~cmerge&#45;&gt;proc~left -->
<g id="proc~~polzeros~~CallsGraph_edge7" class="edge">
<title>proc~cmerge&#45;&gt;proc~left</title>
<path fill="none" stroke="#000000" d="M327.4,-54C335.39,-54 344.31,-54 352.82,-54"/>
<polygon fill="#000000" stroke="#000000" points="352.92,-57.5 362.92,-54 352.92,-50.5 352.92,-57.5"/>
</g>
<!-- proc~right -->
<g id="proc~~polzeros~~CallsGraph_node9" class="node">
<title>proc~right</title>
<g id="a_proc~~polzeros~~CallsGraph_node9"><a xlink:href="../proc/right.html" xlink:title="right">
<polygon fill="#d9534f" stroke="#d9534f" points="417,-24 363,-24 363,0 417,0 417,-24"/>
<text text-anchor="middle" x="390" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">right</text>
</a>
</g>
</g>
<!-- proc~cmerge&#45;&gt;proc~right -->
<g id="proc~~polzeros~~CallsGraph_edge8" class="edge">
<title>proc~cmerge&#45;&gt;proc~right</title>
<path fill="none" stroke="#000000" d="M326.45,-41.85C335.21,-37.67 345.17,-32.92 354.52,-28.46"/>
<polygon fill="#000000" stroke="#000000" points="356.09,-31.59 363.6,-24.12 353.07,-25.27 356.09,-31.59"/>
</g>
</g>
</svg>
</div>          <div>
            <a type="button" class="graph-help" data-bs-toggle="modal" href="#CallsGraph-help-text">Help</a>
          </div>
          <div class="modal fade" id="CallsGraph-help-text" tabindex="-1" role="dialog">
            <div class="modal-dialog modal-lg" role="document">
              <div class="modal-content">
                <div class="modal-header">
                  <h4 class="modal-title" id="-graph-help-label">Graph Key</h4>
                  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
<p>Nodes of different colours represent the following: </p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.43.0 (0)
 -->
<!-- Title: Graph Key Pages: 1 -->
<svg width="641pt" height="28pt"
 viewBox="0.00 0.00 641.00 27.51" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(0.86 0.86) rotate(0) translate(4 28)">
<title>Graph Key</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-28 741.5,-28 741.5,4 -4,4"/>
<!-- Subroutine -->
<g id="node1" class="node">
<title>Subroutine</title>
<polygon fill="#d9534f" stroke="#d9534f" points="70,-24 0,-24 0,0 70,0 70,-24"/>
<text text-anchor="middle" x="35" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Subroutine</text>
</g>
<!-- Function -->
<g id="node2" class="node">
<title>Function</title>
<polygon fill="#d94e8f" stroke="#d94e8f" points="146,-24 88,-24 88,0 146,0 146,-24"/>
<text text-anchor="middle" x="117" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Function</text>
</g>
<!-- Interface -->
<g id="node3" class="node">
<title>Interface</title>
<polygon fill="#a7506f" stroke="#a7506f" points="225.5,-24 164.5,-24 164.5,0 225.5,0 225.5,-24"/>
<text text-anchor="middle" x="195" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Interface</text>
</g>
<!-- Type Bound Procedure -->
<g id="node4" class="node">
<title>Type Bound Procedure</title>
<polygon fill="#a7506f" stroke="#a7506f" points="374,-24 244,-24 244,0 374,0 374,-24"/>
<text text-anchor="middle" x="309" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Type Bound Procedure</text>
</g>
<!-- Unknown Procedure Type -->
<g id="node5" class="node">
<title>Unknown Procedure Type</title>
<polygon fill="#777777" stroke="#777777" points="537.5,-24 392.5,-24 392.5,0 537.5,0 537.5,-24"/>
<text text-anchor="middle" x="465" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Unknown Procedure Type</text>
</g>
<!-- Program -->
<g id="node6" class="node">
<title>Program</title>
<polygon fill="#f0ad4e" stroke="#f0ad4e" points="614,-24 556,-24 556,0 614,0 614,-24"/>
<text text-anchor="middle" x="585" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50" fill="white">Program</text>
</g>
<!-- This Page&#39;s Entity -->
<g id="node7" class="node">
<title>This Page&#39;s Entity</title>
<polygon fill="none" stroke="black" points="737.5,-24 632.5,-24 632.5,0 737.5,0 737.5,-24"/>
<text text-anchor="middle" x="685" y="-9.6" font-family="Helvetica,sans-Serif" font-size="10.50">This Page&#39;s Entity</text>
</g>
</g>
</svg>

<p>Solid arrows point from a procedure to one which it calls. Dashed 
arrows point from an interface to procedures which implement that interface.
This could include the module procedures in a generic interface or the
implementation in a submodule of an interface in a parent module.
</p>
 </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <br>


    
    

    
    



    
    <section>
    <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="hl codehilite"><pre><span></span><span class="w">    </span><span class="k">subroutine </span><span class="n">polzeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">poly</span><span class="p">,</span><span class="w"> </span><span class="n">nitmax</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">)</span>

<span class="w">        </span><span class="k">implicit none</span>

<span class="k">        </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="c">!! degree of the polynomial.</span>
<span class="w">        </span><span class="kt">complex</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">poly</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c">!! complex vector of n+1 components, `poly(i)` is the</span>
<span class="w">                                              </span><span class="c">!! coefficient of `x**(i-1), i=1,...,n+1` of the polynomial `p(x)`</span>
<span class="w">        </span><span class="kt">integer</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">nitmax</span><span class="w"> </span><span class="c">!! the max number of allowed iterations.</span>
<span class="w">        </span><span class="kt">complex</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">root</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! complex vector of `n` components, containing the</span>
<span class="w">                                           </span><span class="c">!! approximations to the roots of `p(x)`.</span>
<span class="w">        </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">radius</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="c">!! real vector of `n` components, containing the error bounds to</span>
<span class="w">                                          </span><span class="c">!! the approximations of the roots, i.e. the disk of center</span>
<span class="w">                                          </span><span class="c">!! `root(i)` and radius `radius(i)` contains a root of `p(x)`, for</span>
<span class="w">                                          </span><span class="c">!! `i=1,...,n`. `radius(i)` is set to -1 if the corresponding root</span>
<span class="w">                                          </span><span class="c">!! cannot be represented as floating point due to overflow or</span>
<span class="w">                                          </span><span class="c">!! underflow.</span>
<span class="w">        </span><span class="kt">logical</span><span class="p">,</span><span class="k">intent</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">err</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w">     </span><span class="c">!! vector of `n` components detecting an error condition:</span>
<span class="w">                                          </span><span class="c">!!</span>
<span class="w">                                          </span><span class="c">!!  * `err(j)=.true.` if after `nitmax` iterations the stop condition</span>
<span class="w">                                          </span><span class="c">!!    (3) is not satisfied for x(j)=root(j);</span>
<span class="w">                                          </span><span class="c">!!  * `err(j)=.false.`  otherwise, i.e., the root is reliable,</span>
<span class="w">                                          </span><span class="c">!!    i.e., it can be viewed as an exact root of a</span>
<span class="w">                                          </span><span class="c">!!    slightly perturbed polynomial.</span>
<span class="w">                                          </span><span class="c">!!</span>
<span class="w">                                          </span><span class="c">!! the vector `err` is used also in the routine convex hull for</span>
<span class="w">                                          </span><span class="c">!! storing the abscissae of the vertices of the convex hull.</span>

<span class="w">        </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="c">!! number of iterations peformed</span>
<span class="w">        </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">apoly</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c">!! auxiliary variable: real vector of n+1 components used to store the moduli of</span>
<span class="w">                                 </span><span class="c">!! the coefficients of p(x) and the coefficients of s(x) used</span>
<span class="w">                                 </span><span class="c">!! to test the stop condition (3).</span>
<span class="w">        </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">apolyr</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="c">!! auxiliary variable: real vector of n+1 components used to test the stop</span>
<span class="w">                                  </span><span class="c">!! condition</span>
<span class="w">        </span><span class="kt">integer</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">nzeros</span>
<span class="w">        </span><span class="kt">complex</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">corr</span><span class="p">,</span><span class="w"> </span><span class="n">abcorr</span>
<span class="w">        </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="nb">amax</span>

<span class="nb">        </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">parameter</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">eps</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">epsilon</span><span class="p">(</span><span class="mf">1.0_wp</span><span class="p">)</span>
<span class="w">        </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">parameter</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">small</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">tiny</span><span class="p">(</span><span class="mf">1.0_wp</span><span class="p">)</span>
<span class="w">        </span><span class="kt">real</span><span class="p">(</span><span class="n">wp</span><span class="p">),</span><span class="k">parameter</span><span class="w"> </span><span class="kd">::</span><span class="w"> </span><span class="n">big</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">huge</span><span class="p">(</span><span class="mf">1.0_wp</span><span class="p">)</span>

<span class="w">        </span><span class="c">! check consistency of data</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">            error stop</span><span class="w"> </span><span class="s1">&#39;inconsistent data: the leading coefficient is zero&#39;</span>
<span class="w">        </span><span class="k">end if</span>
<span class="k">        if</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="k">then</span>
<span class="k">            error stop</span><span class="w"> </span><span class="s1">&#39;the constant term is zero: deflate the polynomial&#39;</span>
<span class="w">        </span><span class="k">end if</span>
<span class="w">        </span><span class="c">! compute the moduli of the coefficients</span>
<span class="w">        </span><span class="nb">amax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0_wp</span>
<span class="w">        </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="n">apoly</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">abs</span><span class="p">(</span><span class="n">poly</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="w">            </span><span class="nb">amax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="nb">amax</span><span class="p">,</span><span class="w"> </span><span class="n">apoly</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="w">            </span><span class="n">apolyr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">apoly</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="k">end do</span>
<span class="k">        if</span><span class="w"> </span><span class="p">((</span><span class="nb">amax</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="n">big</span><span class="o">/</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)))</span><span class="w"> </span><span class="k">then</span>
<span class="k">            write</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;warning: coefficients too big, overflow is likely&#39;</span>
<span class="w">        </span><span class="k">end if</span>
<span class="w">        </span><span class="c">! initialize</span>
<span class="w">        </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>
<span class="w">            </span><span class="n">radius</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0_wp</span>
<span class="w">            </span><span class="n">err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">true</span><span class="p">.</span>
<span class="w">        </span><span class="k">end do</span>
<span class="w">        </span><span class="c">! select the starting points</span>
<span class="w">        </span><span class="k">call </span><span class="n">start</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">apolyr</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="p">,</span><span class="w"> </span><span class="n">nzeros</span><span class="p">,</span><span class="w"> </span><span class="n">small</span><span class="p">,</span><span class="w"> </span><span class="n">big</span><span class="p">)</span>
<span class="w">        </span><span class="c">! compute the coefficients of the backward-error polynomial</span>
<span class="w">        </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="n">apolyr</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eps</span><span class="o">*</span><span class="n">apoly</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">3.8_wp</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="n">apoly</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eps</span><span class="o">*</span><span class="n">apoly</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">3.8_wp</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">end do</span>
<span class="k">        if</span><span class="w"> </span><span class="p">((</span><span class="n">apoly</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="p">)</span><span class="w"> </span><span class="p">.</span><span class="nb">or</span><span class="p">.</span><span class="w"> </span><span class="p">(</span><span class="n">apoly</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0_wp</span><span class="p">))</span><span class="w"> </span><span class="k">then</span>
<span class="k">            write</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;warning: the computation of some inclusion radius&#39;</span>
<span class="w">            </span><span class="k">write</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">&#39;may fail. this is reported by radius=0&#39;</span>
<span class="w">        </span><span class="k">end if</span>
<span class="k">        do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>
<span class="w">            </span><span class="n">err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">true</span><span class="p">.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">radius</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">err</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.</span><span class="n">false</span><span class="p">.</span>
<span class="w">        </span><span class="k">end do</span>
<span class="w">        </span><span class="c">! starts aberth&#39;s iterations</span>
<span class="w">        </span><span class="k">do </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">nitmax</span>
<span class="w">          </span><span class="k">do </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">then</span>
<span class="k">                  call </span><span class="n">newton</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">poly</span><span class="p">,</span><span class="w"> </span><span class="n">apoly</span><span class="p">,</span><span class="w"> </span><span class="n">apolyr</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">small</span><span class="p">,</span><span class="w"> </span><span class="n">radius</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">corr</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="w">                  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="k">then</span>
<span class="k">                      call </span><span class="n">aberth</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">abcorr</span><span class="p">)</span>
<span class="w">                      </span><span class="n">root</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">corr</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">corr</span><span class="o">*</span><span class="n">abcorr</span><span class="p">)</span>
<span class="w">                  </span><span class="k">else</span>
<span class="k">                      </span><span class="n">nzeros</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nzeros</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">                      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nzeros</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">return</span>
<span class="k">                  end if</span>
<span class="k">              end if</span>
<span class="k">          end do</span>
<span class="k">        end do</span>

<span class="k">    end subroutine </span><span class="n">polzeros</span>
</pre></div>

    </section>
    <br>
    
    </div>
  </div>

      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col">
            <p>
              polyroots-fortran
 was developed by Jacob Williams<br>              &copy; 2025 
</p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>
  </body>
</html>